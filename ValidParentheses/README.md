# LeetCode 題解筆記 #20：Valid Parentheses（Swift）

---

## 📂 題目分類

- 題型：Stack 操作
- 難度：Easy
- 練習重點：
    - 熟悉 Stack 資料結構（後進先出，LIFO，亦即先進後出）
    - 括號匹配邏輯處理
    - 字串遍歷與條件判斷

---

## 📝 題目連結  

[https://leetcode.com/problems/valid-parentheses](https://leetcode.com/problems/valid-parentheses)

---

## ❓ 題目說明

給定一個只包含 `()[]{} ` 三種括號的字串 `s`，判斷它是否為**有效的括號組合**。

- 有效的括號需遵守：
  - 每個開括號，都有**對應的閉括號**
  - 括號之間必須**順序正確且嵌套合理**

---

## ✅ 範例

```swift
Input: s = "()"
Output: true

Input: s = "()[]{}"
Output: true

Input: s = "(]"
Output: false

Input: s = "([)]"
Output: false

Input: s = "{[]}"
Output: true
```

---

## 💡 解法一：使用 Stack（堆疊）來配對括號

### 1–1 解法思路

1. 因為括號有「先開後關」的特性，例如：

    - () 是有效的
    - ([{}]) 也是有效的（後進先出）

2. 使用 Stack（後進先出）非常適合處理這類配對問題

---

### 1-2 流程概念

- 這題利用 Stack 處理「先開後關」的括號結構，遇開括號推入、遇閉括號配對刪除，最後 stack 為空即為合法。

| 情境             | 動作說明                                  |
|------------------|-------------------------------------------|
| 遇到開括號       | 推進 stack                                 |
| 遇到閉括號       | 檢查 stack 最上層是否為對應的開括號         |
| 成功配對         | 移除 stack 最上層                          |
| 配對錯誤         | 立即回傳 false（順序錯誤或無可配對項）     |
| 字串讀取完畢     | 若 stack 為空 → ✅ 全部配對成功，回傳 true |
|                  | 若 stack 還有東西 → ❌ 有殘留，回傳 false  |

---

### 1-3 程式碼

```swift
// MARK: - 解法：使用 Stack 配對括號
    
/// 判斷字串 s 是否為有效的括號組合
func isValid(_ s: String) -> Bool {
    
    // 建立一個對照表：每個「閉括號」對應的「開括號」
    let pair: [Character: Character] = [
        ")": "(",
        "]": "[",
        "}": "{"
    ]
    
    // 用一個 Stack 來追蹤「尚未被配對的開括號」
    var stack: [Character] = []
    
    // 逐一讀取字串中的每個字元
    for char in s {
        
        // 如果目前是「閉括號」，才會出現在 pair 中
        if let match = pair[char] {
            
            // 檢查 Stack 最上層是否為「對應的開括號」
            if stack.last == match {
                // 成功配對，移除最上層開括號
                stack.removeLast()
            } else {
                // 配對錯誤（順序不對或沒東西可配）→ 提早結束
                return false
            }
        } else {
            // 如果是「開括號」→ 放進 Stack，等之後來配對
            stack.append(char)
        }
    }
    
    // 所有配對都成功，Stack 會被清空 → 回傳 true
    // 若還有殘留 → 有未配對的開括號 → 回傳 false
    return stack.isEmpty
    
}
```

---

### 1-4 測試範例

```swift
let solution = Solution()

print(solution.isValid("()"))        // true
print(solution.isValid("()[]{}"))    // true
print(solution.isValid("(]"))        // false
print(solution.isValid("([)]"))      // false
print(solution.isValid("{[]}"))      // true
print(solution.isValid("["))         // false
print(solution.isValid(""))          // true
```

--- 

### 1-5 圖解解法流程

1. 範例一： `s = "()"`

| 字元 | Stack | 說明                     |
|------|-------|--------------------------|
| (    | (     | 開括號 → 推進 stack       |
| )    | 空    | ( 配對成功 → 移除        |

✅ Stack 為空 → 回傳 true

---

2. 範例二： `s = "()[]{}"`

| 字元 | Stack | 說明                     |
|------|-------|--------------------------|
| (    | (     | 開括號 → 推進 stack       |
| )    | 空    | ( 配對成功 → 移除        |
| [    | [     | 開括號 → 推進 stack       |
| ]    | 空    | [ 配對成功 → 移除        |
| {    | {     | 開括號 → 推進 stack       |
| }    | 空    | { 配對成功 → 移除        |

✅ Stack 為空 → 回傳 true

---

3. 範例三： `s = "(]"`

| 字元 | Stack | 說明                               |
|------|-------|------------------------------------|
| (    | (     | 開括號 → 推進 stack                 |
| ]    | (     | ❌ ] 不對應 ( → 回傳 false         |

⛔ 這就違反了配對規則 → 結果為 false

---

4. 範例四： `s = "([)]"`

| 字元 | Stack | 說明                                 |
|------|-------|--------------------------------------|
| (    | (     | 開括號 → 推進 stack                   |
| [    | ( [   | 開括號 → 推進 stack                   |
| )    | ( [   | ❌ ) 不對應 [ → 回傳 false           |

⛔ 這就違反了配對規則 → 結果為 false

---

5. 範例五： `s = "{[]}"`

| 字元 | Stack | 說明                                 |
|------|-------|--------------------------------------|
| {    | {     | 開括號 → 推進 stack                   |
| [    | { [   | 開括號 → 推進 stack                   |
| ]    | {     | [ 配對成功 → 移除                    |
| }    | 空    | { 配對成功 → 移除                    |

✅ Stack 為空 → 回傳 true

---

6. 範例六： `s = "["`

| 字元 | Stack | 說明                     |
|------|-------|--------------------------|
| [    | [     | 開括號 → 推進 stack       |

⛔ 字串結束但 Stack 還有殘留 → 回傳 false

---

7. 範例七： `s = ""`

- 字串為空，沒有任何括號
- ✅ 直接符合條件 → 回傳 true

---

### 1-5 語法補充

- `stack.last`： Stack 的最上層元素（最後進來的）
- `stack.append(char)`： 將開括號推入 stack
- `stack.removeLast()`： 成功配對後，將開括號從 stack 移除
- `stack.isEmpty`： 判斷 stack 是否為空，代表是否配對成功

---

### 1-6 為什麼用 Stack

| 特性             | 說明                                       |
|------------------|--------------------------------------------|
| 後進先出（LIFO） | 最後推進的開括號，必須最先被關閉             |
| 簡化嵌套邏輯     | Stack 幫我們記錄括號的嵌套順序               |
| 時間複雜度       | O(n)，只需一次遍歷字串，效率高、邏輯清晰     |

---

## 🧩 延伸理解：先開後關 ＆ Stack 運作原理

### 2-1 🔁 什麼是「先開後關」？

用這段括號來看：

```swift
[ ( ) ]
```

這表示：

- `[` 是最外層的開括號，最後才關（對應 `]`）
- `(` 是裡面的開括號，要先被關閉（對應 `)`）

---

1. 所以「開括號的順序」是：`[ → (`
2. 「關閉的順序」是：`) → ]`
3. 是相反的順序，也就是`「先開的最後關，後開的先關」`
4. 這種結構就叫做： `先開後關`

---

### 2-2 📦 Stack（堆疊）是什麼？

Stack 是一種「後進先出」的資料結構`（LIFO: Last In, First Out）`

1. 想像我們在堆書 📚：

    ```markdown
    最上層 → 第三本 ← 最後放進去
            第二本
    最底層 → 第一本 ← 最早放進去
    ```

2. 當我們要拿書時，只能從最上層拿 → 最後放的，最先拿出來

3. 這就叫做： `LIFO（Last In, First Out）`

---

### 2-3 🧠 為什麼 Stack 適合配對括號？

1. 合法配對流程範例 `{ [ ( ) ] }`

| 字元 | Stack    | 說明                    |
|------|----------|-------------------------|
| `{`  | `{`      | 推進 stack              |
| `[`  | `{ [`    | 推進 stack              |
| `(`  | `{ [ (`  | 推進 stack              |
| `)`  | `{ [`    | `(` 配對成功 → 移除     |
| `]`  | `{`      | `[` 配對成功 → 移除     |
| `}`  | 空       | `{` 配對成功 → 移除     |

✅ 最後 stack 清空 → 所有括號成功配對！

---

2. 錯誤配對範例 `([)]`

| 字元 | Stack  | 結果                            |
|------|--------|---------------------------------|
| `(`  | `(`    | 開括號 → 加入                    |
| `[`  | `( [`  | 開括號 → 加入                    |
| `)`  | `( [`  | ❌ `)` 不是配對 `[` → 錯誤        |

👉 這就違反了配對規則 → 結果為 false

---

3. 小抄總結

| 概念         | 說明                                                   |
|--------------|--------------------------------------------------------|
| 先開後關     | 最裡層的括號要先關，外層的最後關                        |
| Stack 特性   | LIFO → 適合管理這種「對稱配對、嵌套順序」的邏輯         |
| 解題策略     | 遇開括號就推進 stack，遇閉括號就比對並移除最上層項目     |
| 成功條件     | 最後 stack 是空的 → 所有括號成功配對                    |

---

📂 回到主目錄：[返回 LeetCode 題解總表](../README.md)