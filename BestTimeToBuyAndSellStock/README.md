# LeetCode 題解筆記 #121：Best Time to Buy and Sell Stock（Swift）

---

## 📂 題目分類

- 題型：陣列操作、區間最大差值
- 難度：Easy
- 練習重點：
    - 找出最大利潤（低點買入、高點賣出）
    - 暴力雙迴圈（解法一）用來釐清邏輯
    - 建立正確「買低賣高」觀念
    - 線性掃描找最大利潤（解法二）

---

## 📝 題目連結

[https://leetcode.com/problems/best-time-to-buy-and-sell-stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)

---

## ❓ 題目說明

給定一個整數陣列 `prices`，其中 `prices[i]` 表示第 i 天的股票價格。

請找出`「某一天買入、某個未來的日子賣出」`可以獲得的最大利潤。

條件：
- 只能在 **`買入日之後`** 的某一天賣出
- 回傳最大利潤（如果無法獲利則回傳 0）

---

## ✅ 範例

```swift
輸入：prices = [7,1,5,3,6,4]
輸出：5
解釋：在第 2 天（股價 = 1）買入，第 5 天（股價 = 6）賣出，利潤 = 6 - 1 = 5。
```

```swift
輸入：prices = [7,6,4,3,1]
輸出：0
解釋：無論何時買賣都無法獲利，回傳 0。
```

---

## 💡 解法一：暴力法（Brute Force）

### 1–1 思路說明

這題要求「在股價清單中，找出一天買進、一個未來的日子賣出，可以獲得的最大利潤」。

因為條件是：

> 只能在未來某天賣出（賣出日 j > 買入日 i）

我們就可以嘗試列舉所有可能的 `(i, j)` 組合，算出每一對的利潤 `prices[j] - prices[i]`，再從中找出最大值。

---

### 1–2 實作步驟

1. 設一個變數 `maxProfit` 來記錄目前為止的最大利潤（初始值為 0）
2. 用兩層迴圈列出所有 `(i, j)` 配對，`i < j`
3. 算出 `prices[j] - prices[i]`，若利潤 > maxProfit → 更新 maxProfit
4. 回傳最終的 maxProfit

---

### ✅ 總結一句話

> 透過追蹤「目前為止的最低買入價」，每次都嘗試計算「當前價格 - 最低買價」，就能找出最大利潤！

---

### 1–3 程式碼（Swift）

```swift
// MARK: - 解法一：暴力雙迴圈（先建立觀念）
class SolutionOne {
    
    /// 回傳最大利潤
    ///
    /// - `參數 prices`: 股票價格陣列
    /// - `回傳`：可獲得的最大利潤（若永遠不會賺錢 → 回傳 0）
    func maxProfit(_ prices: [Int]) -> Int {
        
        /// 用來記錄目前為止找到的最大利潤
        var maxProfit = 0
        
        /// 外層迴圈：模擬「哪一天買進」
        for i in 0..<prices.count {
            
            /// 內層迴圈：模擬「從第 i+1 天起」嘗試賣出（之後哪一天賣出）
            for j in (i+1)..<prices.count {
                
                /// 利潤 = 賣價 - 買價
                let profit = prices[j] - prices[i]
                
                /// 比較目前最大利潤
                /// 若這筆交易利潤更高，就更新 maxProfit
                maxProfit = max(maxProfit, profit)
            }
        }
        
        /// 回傳最大利潤
        return maxProfit
    }
    
}
```

---

### 1-4 測試範例一（暴力雙迴圈）

```swift
let solutionOne = SolutionOne()

print(solutionOne.maxProfit([7,1,5,3,6,4]))    // ➜ 5
print(solutionOne.maxProfit([7,6,4,3,1]))      // ➜ 0
```

---

### 1–5 範例模擬流程（暴力解所有買賣日組合）

#### 📝 備註：

1. 本表格列出所有可能的 `(i, j)` 組合，其中 `i < j`

2. `i` 為買進日、`j` 為賣出日，使用 `index` 表示（從 0 開始）

3. 若需對應 LeetCode 的「第 N 天」，請記得 `index + 1`
    - 例如：`i = 1` 表示第 2 天，j = 4 表示第 5 天

4. 每一次比較都會計算利潤並嘗試更新 `maxProfit`

---

#### 範例一：最大利潤（prices = [7, 1, 5, 3, 6, 4]）

說明：i = 1 表示第 2 天（股價為 1 元），j = 4 表示第 5 天（股價為 6 元）

> ✅ 最終結果：最大利潤 = 5（在 index = 1〈第 2 天〉買入 1 元，index = 4〈第 5 天〉賣出 6 元）

| 買進日 i | 賣出日 j | prices[i] → prices[j] | 利潤 (`j - i`)  | 是否更新 `maxProfit` |
|----------|----------|------------------------|------|--------------------|
| 0        | 1        | 7 → 1                  | -6   | ❌ maxProfit = 0    |
| 0        | 2        | 7 → 5                  | -2   | ❌ maxProfit = 0    |
| 0        | 3        | 7 → 3                  | -4   | ❌ maxProfit = 0    |
| 0        | 4        | 7 → 6                  | -1   | ❌ maxProfit = 0    |
| 0        | 5        | 7 → 4                  | -3   | ❌ maxProfit = 0    |
| 1        | 2        | 1 → 5                  | 4    | ✅ maxProfit = 4    |
| 1        | 3        | 1 → 3                  | 2    | ❌ maxProfit = 4    |
| 1        | 4        | 1 → 6                  | 5    | ✅ maxProfit = 5    |
| 1        | 5        | 1 → 4                  | 3    | ❌ maxProfit = 5    |
| 2        | 3        | 5 → 3                  | -2   | ❌ maxProfit = 5    |
| 2        | 4        | 5 → 6                  | 1    | ❌ maxProfit = 5    |
| 2        | 5        | 5 → 4                  | -1   | ❌ maxProfit = 5    |
| 3        | 4        | 3 → 6                  | 3    | ❌ maxProfit = 5    |
| 3        | 5        | 3 → 4                  | 1    | ❌ maxProfit = 5    |
| 4        | 5        | 6 → 4                  | -2   | ❌ maxProfit = 5    |

---

#### 範例二：無法獲利（prices = [7, 6, 4, 3, 1]）

> ❌ 價格持續下跌 → 所有交易都為負利潤 → 最終回傳 maxProfit = 0

| 買進日 i | 賣出日 j | prices[i] → prices[j] | 利潤 (`j - i`) | 是否更新 `maxProfit` |
|--------|--------|--------------------------|----------------|-----------------------|
| 0      | 1      | 7 → 6                    | -1             | 否                    |
| 0      | 2      | 7 → 4                    | -3             | 否                    |
| 0      | 3      | 7 → 3                    | -4             | 否                    |
| 0      | 4      | 7 → 1                    | -6             | 否                    |
| 1      | 2      | 6 → 4                    | -2             | 否                    |
| 1      | 3      | 6 → 3                    | -3             | 否                    |
| 1      | 4      | 6 → 1                    | -5             | 否                    |
| 2      | 3      | 4 → 3                    | -1             | 否                    |
| 2      | 4      | 4 → 1                    | -3             | 否                    |
| 3      | 4      | 3 → 1                    | -2             | 否                    |

---

### 1–7 時間與空間複雜度

| 類型   | 複雜度    | 說明                                  |
|--------|------------|---------------------------------------|
| 時間   | O(n²)      | 兩層迴圈比對所有可能的買入賣出組合     |
| 空間   | O(1)       | 僅使用 maxProfit 來記錄結果           |

---

### 1-8 語法複習（針對解法一）

| 語法                          | 說明                                               |
|-------------------------------|----------------------------------------------------|
| `for i in 0..<n`              | 使用 `i` 當作「買入日」的 index（即第 `i+1` 天）                   |
| `for j in (i+1)..<n`          | 使用 `j` 當作「賣出日」，只從未來日子開始檢查（即第 `j+1` 天）    |
| `let profit = prices[j] - prices[i]` | 計算這次交易的利潤（賣價 - 買價）       |
| `max(a, b)`                   | 回傳 a 和 b 中的最大值，用來更新最大利潤           |
| `var maxProfit = 0`           | 預設最大利潤為 0，代表「永遠不賺錢的情況」         |

#### 📝 補充說明：

- 語法中的 `i` 和 `j` 都是以 **陣列 index（從 0 開始）** 表示天數，
- 若要對應題目中「第 N 天」，請將 `index + 1`。

---

## 💡 解法二：線性掃描（One Pass）

### 2–1 思路說明

這題的關鍵在於找出一個「最低買入點」，接著在之後的某一天「賣出」，獲得最大利潤。

與其每次都比對未來的賣出價格，我們可以：

1. 從左到右一次掃過整個陣列

2. 在掃描的同時：
    - 隨時記住目前為止遇到的 最低買入價格 `minPrice`
    - 計算若今天賣出，與目前最低買入價相比可以賺多少
    - 同時更新最大利潤 `maxProfit`

---

#### 🧠 用簡單比喻幫助理解：

1. 假設你是一個「只交易一次」的股民，每天觀察股票價格。

2. 你先準備一張紙條，記錄「目前遇到最便宜的價格」 → 對應程式中的 `minPrice`

3. 每天觀察股價：
    - 如果今天的價格比你紙條上還便宜 → 趕快更新紙條（更新 `minPrice）`
    - 如果今天的價格比較高 → 嘗試把它賣掉，看看這筆交易可以賺多少（今天價格 - 紙條上的最低價）

4. 你每天都在問自己一件事：

    - 「如果我今天賣掉，是不是可以賺最多？」

5. 這個過程就像每天都試著模擬一場交易，但只紀錄「最划算的那次」。

---

#### 🧠 延伸理解：「`minPrice = Int.max` 是做什麼用的？」

這是一種初始化策略，因為我們一開始還不知道最低價是什麼，所以設定為「極大值 Int.max」，這樣只要進來的價格比它小（一定會發生），就能更新為第一天的股價。

---

#### 🧠 重點補充：為什麼需要 `else` 嘗試「用今天賣出」？

程式邏輯中：

```swift
if price < minPrice {
    minPrice = price
} else {
    let profit = price - minPrice
    maxProfit = max(maxProfit, profit)
}
```

| 判斷條件            | 白話意思                         | 行為                                     |
|---------------------|----------------------------------|------------------------------------------|
| `if price < minPrice` | 今天價格更低 → 值得買進           | 更新「最低買入價格」                      |
| `else`              | 今天價格不夠低 → 不買了，那試著賣掉看看 | 計算今天若賣出能不能賺更多，更新「最大利潤」 |

---

#### 🔁 翻成完整白話流程：

```
for 每天的股價 in prices {

    如果今天價格比歷史最低還低 {
        → 更新「買入價」minPrice
    } 否則 {
        → 試著用「今天價格」當作「賣出價」
        → 計算利潤 = 今天價格 - 最低買入價
        → 如果利潤比目前最大利潤還高，更新 maxProfit
    }
}
```

---

### 2–2 實作步驟

1. 設定一個變數 `minPrice`，初始為 `Int.max`（代表還沒找到低點）

2. 設定 `maxProfit = 0`

3. 開始一個 `for` 迴圈，逐天讀取 `price`
    - 若 `price < minPrice`，更新 `minPrice`
    - 否則就計算 `price - minPrice`，並與 `maxProfit` 比較取較大者

4. 回傳最終 maxProfit

---

### ✅ 總結一句話

> 只要記得「買低賣高」的本質就是：一邊記著最低點，一邊試著賣出，就能用一圈搞定最大利潤。

---

### 2-3 範例模擬流程（線性掃描過程觀察）

#### 📝 備註：

1. 表格中以「每天的股價值」為主軸，對應 price 在 for 迴圈中的每次遍歷
2. 每天都記錄：
    - 當前的最低買入價 `minPrice`
    - 當天若賣出可獲得的利潤（`price - minPrice`）
    - 是否需要更新最大利潤 `maxProfit`

---

#### 範例一：可獲得最大利潤（prices = [7, 1, 5, 3, 6, 4]）

#### 📝 補充說明：

- 第 2 天買入價格為最低（1 元），之後第 5 天賣出（6 元）可以獲得最大利潤
- `minPrice` 會在出現新低價時更新，`maxProfit` 則根據每次賣出機會評估是否更新

> ✅ 最終回傳結果：最大利潤 = **5**

| 當天股價 | minPrice（目前最低） | 可以賺多少？（今天價格 - minPrice） | maxProfit 更新？ |
|----------|------------------------|--------------------------------------|------------------|
| 7        | 7                      | -                                    | 無               |
| 1        | ✅ 1（更新）           | -                                    | 無               |
| 5        | 1                      | 5 - 1 = 4                            | ✅ → 4           |
| 3        | 1                      | 3 - 1 = 2                            | 否               |
| 6        | 1                      | 6 - 1 = 5                            | ✅ → 5           |
| 4        | 1                      | 4 - 1 = 3                            | 否               |

---

#### 範例二：無法獲利情境（prices = [7, 6, 4, 3, 1]）

#### 📝 補充說明：

- 價格每日下跌，無法達成「買低賣高」
- `minPrice` 每天都在更新，`maxProfit` 永遠維持 0

> ✅ 最終回傳結果：最大利潤 = **0**（永遠無法獲利）

| 當天股價 | minPrice（目前最低） | 可以賺多少？（今天價格 - minPrice） | maxProfit 更新？ |
|----------|------------------------|--------------------------------------|------------------|
| 7        | 7                      | -                                    | 無               |
| 6        | ✅ 6（更新）           | -                                    | 無               |
| 4        | ✅ 4（更新）           | -                                    | 無               |
| 3        | ✅ 3（更新）           | -                                    | 無               |
| 1        | ✅ 1（更新）           | -                                    | 無               |

---

### 2–4 程式碼

```swift
// MARK: - 解法二：線性掃描（一次遍歷）
class SolutionTwo {
    
    /// 回傳最大利潤
    ///
    /// - `參數 prices`: 股票價格陣列
    /// - `回傳`：可獲得的最大利潤（若永遠不會賺錢 → 回傳 0）
    func maxProfit(_ prices: [Int]) -> Int {
        
        /// 紀錄目前為止「最低的買入價格」
        /// 初始設為 `Int.max`，確保第一筆價格一定會被取代
        var minPrice = Int.max
        
        /// 紀錄目前為止「最大利潤」
        var maxProfit = 0
        
        /// 一次迴圈遍歷整個價格陣列
        for price in prices {
            
            /// 如果今天的價格更便宜 → 更新目前最低價（`minPrice`）
            if price < minPrice {
                
                minPrice = price
                
            } else {
                
                /// 否則表示今天價格比歷史低點高
                /// 試著用今天價格「賣出」，看看能賺多少
                let profit = price - minPrice
                
                /// 若利潤更高，就更新 maxProfit
                maxProfit = max(maxProfit, profit)
            }
        }
        
        /// 回傳最終計算出的最大利潤
        return maxProfit
    }
}
```

---

### 2-5 測試範例二（線性掃描）

```swift
let solutionTwo = SolutionTwo()

print(solutionTwo.maxProfit([7,1,5,3,6,4]))    // ➜ 5
print(solutionTwo.maxProfit([7,6,4,3,1]))      // ➜ 0
```

---

### 2-6 時間與空間複雜度

| 類型   | 複雜度 | 說明                                      |
|--------|--------|-------------------------------------------|
| 時間   | O(n)   | 只需掃描一次陣列                          |
| 空間   | O(1)   | 僅使用兩個變數（`minPrice` 與 `maxProfit`） |

#### 📌 回顧比較

> 相較於解法一（O(n²) 暴力解），這個解法效率更高、邏輯更清晰，是實務中最推薦的方式。

---

## 📘 Swift 語法補充：`max(_:_:)`

在本題中，會用到 Swift 內建的 `max(_:_:)` 函式來找出兩個值之中較大的那個。這對於更新最大利潤 `maxProfit` 非常重要。

| 語法                   | 說明                                                                                   |
|------------------------|----------------------------------------------------------------------------------------|
| `max(a, b)`            | 比較 a 與 b，回傳其中較大的值。例如：`max(3, 5)` ➜ 回傳 5。                            |
| 實務應用               | 可用來更新目前為止的最大值，避免使用 `if` 判斷式來手動比較。                          |
| 本題範例用法           | `maxProfit = max(maxProfit, profit)`：若這次利潤更高，就更新最大利潤。                  |

### 📌 補充說明：

這樣的寫法等同於：

```swift
if profit > maxProfit {
    maxProfit = profit
}
```

---

📂 回到主目錄：[返回 LeetCode 題解總表](../README.md)