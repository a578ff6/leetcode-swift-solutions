# 📘 LeetCode #88 - Merge Sorted Array（Swift）

---

## 📂 題目分類

- 題型：陣列合併、雙指標操作（Two Pointers）
- 難度：Easy
- 練習重點：
    - 熟悉雙指標走訪已排序陣列的方式
    - 練習「合併兩個排序陣列」的常見模式
    - 模擬合併流程、處理剩餘資料
    - 差異化練習：使用新陣列 vs in-place 原地合併（進階版）

---

## 📝 題目連結

[https://leetcode.com/problems/merge-sorted-array/](https://leetcode.com/problems/merge-sorted-array/)

---

## ❓ 題目說明

1. 你有兩個排序過的整數陣列 `nums1` 和 `nums2。`

- `nums1` 的長度是 `m + n`，前 `m` 個元素是有效的整數，其餘都是 `0`，用來容納 `nums2`

- `nums2` 的長度是 `n`，包含 `n` 個排序好的整數

2. 請你「就地（in-place）合併 `nums2` 到 `nums1` 中，使 `nums1` 成為一個排序後的陣列」。

--

## ✅ 範例

- 範例一

```swift
Input: nums1 = [1,2,3,0,0,0], m = 3,
       nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```

- 範例二

```swift
Input: nums1 = [1], m = 1,
       nums2 = [],  n = 0

Output: [1]
```

- 範例三

```swift
Input: nums1 = [0], m = 0,
       nums2 = [1], n = 1

Output: [1]
```

---

## 💡 解法一：使用新陣列合併（Two Pointers）

### 1-1 思路說明

- 我們可以使用 兩個指標 i 和 j，分別遍歷 `nums1` 與 `nums2` 的有效部分，每次比較兩邊的數字，將較小者加入新的 `merged` 陣列中。

- 當其中一邊走完後，再把剩下的數字補進 `merged`，最後再 複製回 `nums1`。

---

### 1–2 實作步驟

1. 建立一個新的 `merged` 陣列，作為結果儲存容器
2. 宣告兩個指標 `i` 和 `j`，用來走訪 `nums1`（前 m 個有效數字）與 `nums2`
3. 使用 `while` 迴圈：
    - 比較 nums1[i] 和 nums2[j] 的大小
    - 將較小者加入 `merged`，並將對應的指標往右移動（`i += 1` 或 `j += 1`）
4. 若某一邊先比完，將另一邊剩下的元素補進 `merged`
5. 最後，將 `merged` 的所有值回寫進 `nums1` 的前 `m + n` 個位置

---

### ✅ 總結一句話

> 使用兩個指標遍歷 nums1 和 nums2，每次挑出較小的元素加入新陣列，最後回寫回 nums1。

---

### 1-3 程式碼

```swift
// MARK: - 解法一：使用額外陣列合併（基礎觀念練習）
class SolutionOne {
    
    /// 合併兩個已排序的陣列，將 nums2 的元素合併進 nums1
    ///
    /// - Parameters:
    ///   - nums1: 主陣列，長度為 m + n，前 m 個為有效數字，其餘為 0（預留空間）
    ///   - m: nums1 中有效元素的數量
    ///   - nums2: 欲合併進來的排序陣列
    ///   - n: nums2 的元素數量
    ///
    /// - 操作：
    ///   1. 使用兩個指標 i 和 j 分別遍歷 nums1 與 nums2
    ///   2. 每次比較兩邊當前元素，將較小者加入 merged 陣列中
    ///   3. 若其中一邊先走完，就將另一邊剩下的全部加入
    ///   4. 最後將 merged 的結果覆蓋寫回 nums1（in-place）
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        
        /// 用來存放最終排序好的合併結果
        var merged: [Int] = []
        
        /// 指標 i 用於走訪 nums1 的前 m 個有效數字
        var i = 0
        /// 指標 j 用於走訪 nums2 的全部元素
        var j = 0
        
        /// 同步遍歷兩陣列，只要兩邊都還有元素可比
        while i < m && j < n {
            if nums1[i] < nums2[j] {
                // 若 nums1[i] 較小，加入 merged，並前進 i
                merged.append(nums1[i])
                i += 1
            } else {
                // 若 nums2[j] 較小或相等，加入 merged，並前進 j
                merged.append(nums2[j])
                j += 1
            }
        }
        
        /// nums1 可能還有剩下未處理的元素，全部補進 merged
        while i < m {
            merged.append(nums1[i])
            i += 1
        }
        
        /// nums2 可能還有剩下未處理的元素，全部補進 merged
        while j < n {
            merged.append(nums2[j])
            j += 1
        }
        
        /// 最後將合併好的 merged 陣列內容複製回 nums1 前 m+n 位
        for k in 0..<m+n {
            nums1[k] = merged[k]
        }
    }
    
}
```

---

### 1-4 測試範例一

```swift
var nums1 = [1,2,3,0,0,0]
let m = 3
let nums2 = [2,5,6]
let n = 3

let solutionOne = SolutionOne()
solutionOne.merge(&nums1, m, nums2, n)
print(nums1)  // 預期輸出: [1,2,2,3,5,6]
```

---

### 1–5 範例模擬流程

#### 範例一：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

> ✅ 最後覆蓋回 nums1 ➜ [1, 2, 2, 3, 5, 6]

| 指標 i | 指標 j | nums1[i] | nums2[j] | 動作                                 | merged 結果             |
|--------|--------|----------|----------|--------------------------------------|--------------------------|
| 0      | 0      | 1        | 2        | 加入 nums1[i]（1）→ i += 1           | [1]                      |
| 1      | 0      | 2        | 2        | 加入 nums2[j]（2）→ j += 1           | [1, 2]                   |
| 1      | 1      | 2        | 5        | 加入 nums1[i]（2）→ i += 1           | [1, 2, 2]                |
| 2      | 1      | 3        | 5        | 加入 nums1[i]（3）→ i += 1           | [1, 2, 2, 3]             |
| -      | 1      | -        | 5        | nums1 用完，補進 nums2[j]（5）→ j += 1 | [1, 2, 2, 3, 5]          |
| -      | 2      | -        | 6        | 補進 nums2[j]（6）→ j += 1           | [1, 2, 2, 3, 5, 6]       |

---

#### 範例二：nums1 = [1], m = 1, nums2 = [], n = 0

> ✅ 最後覆蓋回 nums1 ➜ [1]（不變）

| 指標 i | 指標 j | nums1[i] | nums2[j] | 動作                            | merged 結果 |
|--------|--------|----------|----------|---------------------------------|-------------|
| 0      | -      | 1        | -        | nums2 為空 → 補進 nums1[i]（1）→ i += 1 | [1]         |

---

#### 範例三：nums1 = [0], m = 0, nums2 = [1], n = 1

> ✅ 最後覆蓋回 nums1 ➜ [1]

| 指標 i | 指標 j | nums1[i] | nums2[j] | 動作                            | merged 結果 |
|--------|--------|----------|----------|---------------------------------|-------------|
| -      | 0      | -        | 1        | nums1 為空 → 補進 nums2[j]（1）→ j += 1 | [1]         |

---

### 1-5 時間與空間複雜度

| 分析項目 | 複雜度     | 說明                                  |
|----------|------------|---------------------------------------|
| 時間     | O(m + n)   | 需要遍歷兩個陣列                       |
| 空間     | O(m + n)   | 額外建立 `merged` 陣列儲存結果         |

---

### 1-6 語法複習

| 語法                           | 說明                                                                 |
|--------------------------------|----------------------------------------------------------------------|
| `while i < m && j < n`        | 同時走訪 `nums1` 和 `nums2`，只要兩邊都還有資料可以比對就繼續          |
| `nums1[i] < nums2[j]`         | 比較目前兩個指標指向的數值大小                                       |
| `merged.append(...)`          | 把較小的元素加入新的陣列 `merged` 中                                  |
| `i += 1`, `j += 1`            | 比較完畢後，將對應指標往後移動，表示該元素已處理完                    |
| `while i < m`、`while j < n`  | 處理「其中一邊先跑完」的情況，把剩下的元素補進 `merged`              |
| `for k in 0..<m+n`            | 最後一步：把合併好的 `merged` 結果寫回 `nums1` 前 `m+n` 個位置        |
| `nums1[k] = merged[k]`        | 實際把資料覆蓋到 `nums1`，完成「就地合併」的動作                      |

--- 

### 1–7 🧠 延伸理解：雙指標合併核心觀念

當兩個陣列都有元素可以比較時：

→ 如果 `nums1[i]` 比較小：
    → 加進結果陣列 → `i += 1`  
→ 否則（`nums2[j]` 較小或相等）：
    → 加進結果陣列 → `j += 1`  

📌 誰小誰先走，指標往後移，這就是「已排序陣列合併」的精髓！

這其實就是模擬 Merge Sort 的合併步驟，也是 Two Pointers 應用模式之一。

---

舉例說明：

```
nums1 = [1,2,3]  
nums2 = [2,5,6]  
合併結果為：[1,2,2,3,5,6]
```

---

## 💡 解法二：從後往前合併（In-Place）

### 2–1 思路說明

這題的進階作法是直接在 `nums1` 的原地完成合併，不另外開陣列。關鍵在於：

- `nums1` 最後面有預留空間，可以從「後面開始填」來避免覆蓋原有資料。
- 利用 倒序指標（`p1`、`p2`、`p`）：從兩陣列尾端開始比較，將較大的值放進 `nums1` 最尾端。

---

#### 三個關鍵指標

為了實作「從後往前合併」，會使用三個倒序指標：

| 指標變數 | 初始值       | 用途說明                                  |
|----------|--------------|---------------------------------------------|
| `p1`     | `m - 1`      | 指向 `nums1` 中 **最後一個有效元素**         |
| `p2`     | `n - 1`      | 指向 `nums2` 中 **最後一個元素**             |
| `p`      | `m + n - 1`  | 指向 `nums1` 的最尾端 → 用來「填入合併結果」 |

---

#### 精華邏輯總結

1. 這就是 Merge Sort 的 merge 精神 + 雙指標技巧

2. 從兩邊最後一格往前比：
  - 誰比較大，就把誰放進 `nums1[p]`
  - 然後往前推進一格

3. 只要把大的數字從後面填進去，就能避開覆蓋問題

---

### ✅ 一句話總結

> 從陣列尾部開始比較，把大的值往後填，達成 in-place 合併。

---

### 2–2 程式碼（倒序合併）

```swift
// MARK: - 解法二：從後往前合併（In-place 原地合併）

class SolutionTwo {
    
    /// 合併兩個已排序的陣列（in-place 不使用額外空間）
    ///
    /// - nums1：主陣列，長度為 m + n，前 m 個是有效資料，後面是 0 占位
    /// - m：nums1 的有效元素數量
    /// - nums2：次陣列，長度為 n
    /// - n：nums2 的元素數量
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        
        /// `p1`：指向 `nums1` 有效資料的最後一個位置（m - 1）
        var p1 = m - 1
        
        /// `p2`：指向 `nums2` 的最後一個元素（n - 1）
        var p2 = n - 1
        
        /// `p`：指向 `nums1` 最尾端的位置（m + n - 1），也是填入結果的位置
        var p = m + n - 1
        
        /// 從陣列尾端開始合併，誰大誰放後面
        while p1 >= 0 && p2 >= 0 {
            if nums1[p1] > nums2[p2] {
                /// 若 `nums1` 的元素比較大，放入 `nums1` 的尾端，`p1` 往前
                nums1[p] = nums1[p1]
                p1 -= 1
            } else {
                /// 否則放入 `nums2` 的元素，`p2` 往前
                nums1[p] = nums2[p2]
                p2 -= 1
            }
            /// 每次填完一個數字，`p` 一定要往前
            p -= 1
        }
        
        /// 補上 `nums2` 剩下還沒合併的元素
        /// 若 `nums2` 還沒走完（代表 `nums1` 的比較值都比較大已放完）
        while p2 >= 0 {
            nums1[p] = nums2[p2]
            p2 -= 1
            p -= 1
        }
        
        // 補充說明：
        // 不需要處理 nums1 剩下的值，因為它們已經在正確位置上
    }
    
}
```

---

### 2–3 測試範例二

```swift
var nums1 = [1,2,3,0,0,0]
let m = 3
let nums2 = [2,5,6]
let n = 3

let solutionTwo = SolutionTwo()
solutionTwo.merge(&nums1, m, nums2, n)
print(nums1)  // ➜ [1,2,2,3,5,6]
```

---

### 2–4 模擬流程（倒序合併觀念）

#### 範例一：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

> ✅ 此例中 `m = 3`、`n = 3`，兩個陣列都有有效資料。從最後一格開始往前比對並寫入，最終 `nums2` 先被用完，合併完成。這是「一般情境」下最典型的應用場景。

| p1 位置 | p2 位置 | 比較     | 動作說明                          | 寫入位置 p | nums1 更新結果     |
|---------|---------|----------|-----------------------------------|-------------|----------------------|
| 2       | 2       | 3 vs 6   | 寫入 6 → p2 -= 1, p -= 1          | 5           | [1,2,3,0,0,6]        |
| 2       | 1       | 3 vs 5   | 寫入 5 → p2 -= 1, p -= 1          | 4           | [1,2,3,0,5,6]        |
| 2       | 0       | 3 vs 2   | 寫入 3 → p1 -= 1, p -= 1          | 3           | [1,2,3,3,5,6]        |
| 1       | 0       | 2 vs 2   | 寫入 2 → p2 -= 1, p -= 1          | 2           | [1,2,2,3,5,6]        |
| 1       | -       | 結束     | nums2 已空，結束                  | -           | 完成合併 ✅           |

---

#### 範例二：nums1 = [1], m = 1, nums2 = [], n = 0

> ✅ 此例中 `p2 = -1``，while` 迴圈條件 `p2 >= 0` 不成立，直接跳過。

| p1 位置 | p2 位置 | 比較 | 動作說明                    | 寫入位置 p | nums1 更新結果 |
|---------|---------|------|-----------------------------|-------------|----------------|
| 0       | -       | -    | nums2 為空 → 不需動作 ✅     | -           | [1]（維持不變） |

---

#### 範例三：nums1 = [0], m = 0, nums2 = [1], n = 1

> ✅ 此例中 `m = 0` → `p1 = -1`，主比較迴圈直接跳過，進入收尾流程補上 `nums2` 的剩餘資料。

| p1 位置 | p2 位置 | 比較 | 動作說明                | 寫入位置 p | nums1 更新結果 |
|---------|---------|------|-------------------------|-------------|----------------|
| -       | 0       | -    | 寫入 1 → p2 -= 1, p -= 1 | 0           | [1]            |

---

### 2–5 時間與空間複雜度

| 分析項目 | 複雜度   | 說明                                      |
|----------|----------|-------------------------------------------|
| 時間     | O(m + n) | 最多比對 `m+n`次                           |
| 空間     | O(1)     | 使用 in-place 策略，不開額外陣列          |

---

### 2-6 語法複習

| 語法/指令                      | 用途與說明                                                                 |
|-------------------------------|----------------------------------------------------------------------------|
| `var p1 = m - 1`              | 設定 `p1` 為 `nums1` 最後一個有效數字的 index（從尾巴往回走）               |
| `var p2 = n - 1`              | 設定 `p2` 為 `nums2` 最後一個元素的 index                                  |
| `var p = m + n - 1`           | 設定 `p` 為 `nums1` 的最後一格，用來填入合併結果                           |
| `while p1 >= 0 && p2 >= 0`    | 兩個指標都還有資料時，持續比較合併                                        |
| `if nums1[p1] > nums2[p2]`    | 比較兩數大小，誰大就放在最後（`p` 位置），並將對應指標往前（`p1` 或 `p2`） |
| `nums1[p] = nums1[p1]`        | 把 `nums1[p1]` 複製到尾巴（`p`），完成這一步合併                            |
| `p1 -= 1`, `p2 -= 1`, `p -= 1`| 每次選完一個數字，對應指標往前一格，準備比較下一組數字                     |
| `while p2 >= 0`               | 如果 `nums2` 還有剩下的元素，就補到 `nums1` 裡                             |
| `nums1[p] = nums2[p2]`        | 把剩下的 `nums2` 元素一個個從後往前補到 `nums1` 裡                         |

---

#### 💡 小提醒

- 解法二的技巧就是：先放大數、後放小數，從後面塞回去 → 避免覆蓋 `nums1` 前段的原始資料。
- 這類從尾巴往前填的「倒序合併」邏輯，在 `in-place` 題型中非常常見，尤其是當陣列一方預留空間時。

---

### 2-7 為什麼只補 `nums2`？（邏輯解析）

#### 💭 思考情境：「當 nums2 的元素都比較小，而且還沒放完」

- 這時 `nums1` 的值比較大，而 `nums2` 比較小。

```
nums1 = [4, 5, 6, 0, 0, 0],  m = 3  
nums2 = [1, 2, 3],          n = 3
```

---

#### 🧠 我們的合併策略

```
var p1 = m - 1 // 2 → 指向 6
var p2 = n - 1 // 2 → 指向 3
var p  = m + n - 1 // 5 → 指向 nums1 最尾
```

---

#### 🧮 模擬流程表格

| p1  | p2  | nums1[p1] | nums2[p2] | 動作說明                          | 寫入位置 p | nums1 更新結果       |
|-----|-----|-----------|-----------|-----------------------------------|-------------|------------------------|
| 2   | 2   | 6         | 3         | 寫入 6 → p1 -= 1                  | 5           | [4,5,6,0,0,6]          |
| 1   | 2   | 5         | 3         | 寫入 5 → p1 -= 1                  | 4           | [4,5,6,0,5,6]          |
| 0   | 2   | 4         | 3         | 寫入 4 → p1 -= 1                  | 3           | [4,5,6,4,5,6]          |
| -1  | 2   | (結束)    | 3         | 👉 `p1` 沒了 → 補 `nums2`         | 2           | [4,5,3,4,5,6]          |
| -1  | 1   | (結束)    | 2         | 繼續補 `nums2` → p2 -= 1          | 1           | [4,2,3,4,5,6]          |
| -1  | 0   | (結束)    | 1         | 繼續補 `nums2` → p2 -= 1          | 0           | [1,2,3,4,5,6] ✅        |

---

#### 🔍 關鍵觀察

- p1 變成 -1 的那一刻：`nums1` 的有效元素都已經被填入正確位置
- 這時若 `nums2` 還有剩下的「比較小的元素」沒填完 → 才進入 `while p2 >= 0`

---

#### ✅ 為什麼不需要補 nums1？

因為這是 從尾巴開始填值，當 `nums1[p1]` > `nums2[p2]`，就會被立即放進 `nums1[p]`：

- `nums1` 的值 已經在正確的後面
- 如果 `nums1` 有剩，那些值也都已經「躺在該躺的位置上」啦

---

#### ✅ 為什麼只補 nums2？

唯一沒被寫進去的，會是 `nums2` 比較小的部分，例如：`1、2、3`
它們會在 `nums1` 的開頭處被補上，這時候 `p1` 已經沒了，只有 `p2` 還在跑 

```swift
while p2 >= 0 {
    nums1[p] = nums2[p2]
    p2 -= 1
    p -= 1
}
```

---

#### 小結論

- 使用倒序合併時，`nums1` 的值會直接寫到尾端，因此如果 `nums1` 還沒走完，也已經在正確位置上。
- 唯一會「沒放完」的，是 `nums2` 比較小的值，因此只需要補 `nums2` 就可以了

| 情況          | 發生時機                 | 結果與處理方式                                                        |
|---------------|--------------------------|------------------------------------------------------------------------|
| `p2` 先變成 -1 | `nums2` 全部被合併完了   | ✅ `nums1` 的值都比它大 → 已在正確位置，不需動作                       |
| `p1` 先變成 -1 | `nums1` 的值都已用完     | ✅ `nums2` 還有剩下 → 用 `while p2 >= 0` 補上                           |

---

📂 回到主目錄：[返回 LeetCode 題解總表](../README.md)