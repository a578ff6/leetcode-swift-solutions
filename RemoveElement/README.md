# LeetCode 題解筆記 #27：Remove Element（Swift）

---

## 📂 題目分類

- 題型：陣列操作、Two Pointers
- 難度：Easy
- 練習重點：
  - 使用雙指標（Two Pointers）技巧
  - 原地修改（in-place）陣列
  - 移除特定元素並回傳新長度

---

## 📝 題目連結

[https://leetcode.com/problems/remove-element](https://leetcode.com/problems/remove-element)

---

## ❓ 題目說明

1. 給定一個整數陣列 `nums` 和一個目標值 `val`，請就地（in-place）移除所有等於 `val` 的元素，並回傳新的陣列長度。

2. 要求：
  - 不可以使用額外陣列空間
  - 回傳的長度 `k`，表示移除後陣列的有效長度
  - 函式需修改原陣列 `nums`，但剩下的值內容不重要

---

## ✅ 範例

```swift
Input: nums = [3,2,2,3], val = 3
Output: 2
// nums 被修改為 [2,2,_,_]

Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5
// nums 被修改為 [0,1,3,0,4,_,_,_]
```

---

## 💡 解法一：使用 Two Pointers（雙指標）

### 1–1 思路說明

使用兩個指標：

| 指標名稱 | 用途說明                                 |
|----------|------------------------------------------|
| `i`      | 用來遍歷原始陣列每個元素                  |
| `k`      | 用來記錄目前「保留區」的尾端 index         |

---

### 1–2 流程說明

當 `nums[i] != val`，代表這個值要保留：

- 把 `nums[i]` 複製到 `nums[k]`
- 然後 `k += 1`，往下推一格
- 最後 `k` 就是新陣列的長度。

#### 🧾 一句話總結

- 使用雙指標法，逐一檢查每個元素，**只保留不等於目標值的元素**，依序往前複寫，最後回傳保留區的長度。

---

### 1–3 程式碼範例

```swift
// MARK: - 解法一（Two Pointers）
class SolutionOne {
    
    /// 從陣列 `nums` 中移除所有等於 `val` 的元素（原地處理），並回傳新長度
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        
        /// k 用來表示「保留區」的起點位置
        /// - 意思是：我們會把不等於 val 的值，依序塞進 nums[0...k]
        var k = 0
        
        /// 使用 i 指標，逐一掃描整個 nums 陣列
        for i in 0..<nums.count {
            
            /// 如果目前元素不是 `val`，代表是要保留的數字
            if nums[i] != val {
                
                /// 將這個元素複製到 nums[k]（保留區的下一格）
                nums[k] = nums[i]
                
                /// 保留區右移一格，準備放下個有效元素
                k += 1
            }
            /// 若 `nums[i] == val`，代表要移除 → 什麼都不做，自動跳過
        }
        
        /// 回傳有效元素的個數，也就是保留區的長度
        return k
    }
}
```

---

### 1–4 圖解流程（以 nums = [3,2,2,3], val = 3 為例）

| i | nums[i] | val | 動作說明                          | nums（變動過程） | k（處理後） |
|---|---------|-----|-----------------------------------|------------------|--------------|
| 0 | 3       | 3   | ❌ 等於 val，略過                 | [3,2,2,3]         | 0            |
| 1 | 2       | 3   | ✅ 不等於 val → 複製到 nums[0]，k+=1 | [2,2,2,3]         | 1            |
| 2 | 2       | 3   | ✅ 不等於 val → 複製到 nums[1]，k+=1 | [2,2,2,3]         | 2            |
| 3 | 3       | 3   | ❌ 等於 val，略過                 | [2,2,2,3]         | 2            |

👉 最後有效陣列為 nums[0...1] = [2,2]，回傳長度 k = 2

---

### 1–5 流程圖解（以 nums = [0,1,2,2,3,0,4,2], val = 2 為例）

| i | nums[i] | val | 動作說明                          | nums（變動過程）   | k（處理後） |
|---|---------|-----|-----------------------------------|--------------------|--------------|
| 0 | 0       | 2   | ✅ 不等於 val → 複製到 nums[0]，k+=1 | [0,1,2,2,3,0,4,2]   | 1            |
| 1 | 1       | 2   | ✅ 不等於 val → 複製到 nums[1]，k+=1 | [0,1,2,2,3,0,4,2]   | 2            |
| 2 | 2       | 2   | ❌ 等於 val，略過                 | [0,1,2,2,3,0,4,2]   | 2            |
| 3 | 2       | 2   | ❌ 等於 val，略過                 | [0,1,2,2,3,0,4,2]   | 2            |
| 4 | 3       | 2   | ✅ 不等於 val → 複製到 nums[2]，k+=1 | [0,1,3,2,3,0,4,2]   | 3            |
| 5 | 0       | 2   | ✅ 不等於 val → 複製到 nums[3]，k+=1 | [0,1,3,0,3,0,4,2]   | 4            |
| 6 | 4       | 2   | ✅ 不等於 val → 複製到 nums[4]，k+=1 | [0,1,3,0,4,0,4,2]   | 5            |
| 7 | 2       | 2   | ❌ 等於 val，略過                 | [0,1,3,0,4,0,4,2]   | 5            |

👉 回傳長度 k = 5，有效內容為 nums[0...4] = [0,1,3,0,4]

---

### 1–6 語法複習

| 語法                    | 說明                                                       |
|-------------------------|------------------------------------------------------------|
| `for i in 0..<nums.count` | 使用索引 `i` 循序掃描陣列的每個位                                  |
| `nums[i] != val`        | 檢查目前這個值是不是我們不要刪除的 → 若不是目標值，就保留下來             |
| `nums[k] = nums[i]`     | 將保留的元素複製到前方的保留區位置                          |
| `k += 1`                | 保留區往後推進一格                                           |
| `inout` 關鍵字          | 表示傳入的陣列可以直接修改（原地處理）                      |
| `return k`              | 回傳新的有效陣列長度                                        |

---

### 🔍 額外補充

- `nums[k] = nums[i]` 的意義是什麼？
    - 這行代表「將掃描到的合法元素（nums[i]），移到保留區的下一個空位（nums[k]）」
    - 保證前 k 個位置，都是符合條件的元素

- 為什麼可以覆蓋原陣列？
    - 因為題目允許我們**就地修改**（in-place），只需回傳新的長度 `k` 即可
    - 後面未處理的元素不用管，因為不會被視為新陣列的有效部分

- `k` 的角色可以理解為「下次要放保留元素的位置」  
    - 一開始是 `0`，每當找到合法值就往後推一格

---

📂 回到主目錄：[返回 LeetCode 題解總表](../README.md)